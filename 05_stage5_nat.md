# 第五阶段：NAT 与路由指针 (网络黑魔法)

*类比 C 语言：指针操作与内存地址重写。*

---

在 C 语言中，你可以通过指针修改别人内存里的值。
在网络世界中，**NAT (Network Address Translation，网络地址转换)** 就是修改数据包的“寄件人地址 (源地址)”或“收件人地址 (目的地址)”。

这通常发生在路由器或者容器宿主机上（比如 Docker 就会大量使用 NAT）。在 `nftables` 中做 NAT，我们需要创建一个专门的 `nat` 表。

## 1. NAT 的时机：内核生命周期回顾

还记得那 5 个钩子吗？修改地址的时机是有严格讲究的。

- **Prerouting（路由前）**：你想要修改**包的目的地 (DNAT)** 时，必须在这里改。试想，如果路由已经做出了决定（向左走还是向右走），你再改目的地就晚了！
- **Postrouting（路由后）**：你想要修改**包的出发地 (SNAT)** 时，必须在这里改。此时路由已经定好，马上要出物理网卡了，临出门前赶紧把衣服上的名牌换成自己的。

## 2. Source NAT (SNAT) 与 Masquerade (源地址池隐藏)

**使用场景：把你的 Linux 变成一台路由器**。
假设你有一台服务器（两张网卡：`eth0` 连公网 IP，`eth1` 连内网 `192.168.1.0/24`）。内网的机器想上网，必须通过这台服务器。

内网机器发出的包，源地址是 `192.168.1.x`。如果服务器直接转发它去公网，公网的路由器是不认私网 IP 的，回包永远找不到路。
因此，服务器必须在包出城前，把源地址**替换**成服务器自己的公网 IP。

在 `nftables` 的 `nat` 表中：

```nftables
table ip nat {
    # 必须挂载在 postrouting（路由后）
    chain postrouting {
        type nat hook postrouting priority 100; policy accept;
        
        # 方式一：固定 IP 的 SNAT
        # 如果从内网发出的包属于 192.168.1.0/24，把它源地址改成 203.0.113.5
        ip saddr 192.168.1.0/24 snat to 203.0.113.5
        
        # 方式二：更智能的 Masquerade (伪装)
        # 如果你的公网 IP 不是固定的（比如 PPPoE 拨号或 DHCP 获取的）
        # Masquerade 会自动侦测出口网卡 eth0 当前的 IP，然后用它替换。
        oifname "eth0" masquerade
    }
}
```

## 3. Destination NAT (DNAT) 与端口映射

**使用场景：把公网流量转发给内网容器/服务器**。
假设你启动了一个 Docker 容器（内网 IP `172.17.0.2`，跑在 80 端口）。你想让外部访问你宿主机公网 IP 的 `8080` 端口时，自动连到容器去。

这属于典型的**端口映射**。因为包从外面进来，目的是你的宿主机 `8080`，你必须在**路由判断前**，把包的**目的地址和端口**强行改成容器的地址！

```nftables
table ip nat {
    # 必须挂载在 prerouting（路由前）
    chain prerouting {
        type nat hook prerouting priority -100; policy accept;
        
        # DNAT 规则：进站流量如果是请求 8080 端口的 TCP
        # 直接把目的地址改写成容器的 IP:80 端口！
        tcp dport 8080 dnat to 172.17.0.2:80
    }
}
```

> [!IMPORTANT]
> **NAT 的巨坑提醒：**
> 1. 要做 NAT 和路由转发，**必须**开启 Linux 内核的 IP 转发功能。否则无论你怎么配防火墙，包在路由环节就会被阻断。
>    `echo 1 > /proc/sys/net/ipv4/ip_forward` （临时生效）
>    修改 `/etc/sysctl.conf` 加一行 `net.ipv4.ip_forward = 1` （永久生效）。
> 2. NAT 仅仅是改地址，它仍然会受到 `filter` 表中 `forward` 链的过滤。所以除了写 NAT 规则，确保你的 `filter forward` 链也做了相应的 `accept` 放行！

### 验证端口映射 (DNAT)

我们来手工实现和验证类似 `docker run -p` 的流量转发魔法。

**测试目标：** 向靶机请求 8080 端口，靶机通过 DNAT 将流量转交给内部的 80 端口。由于配置中假设的容器 IP (`172.17.0.2`) 可能有变，请在应用规则前，把脚本里的 `172.17.0.2` 替换为你靶机的真实 IP。

**1. 在容器内启动监听：**
在跑着这套 NAT 规则的容器 `nft-lab` 内，我们在真实的目标端口 80 启动一个服务：
```bash
nc -l -p 80 &
```

**2. 在宿主机测试转发口：**
在宿主机上，向容器的伪装转发端口 8080 发起连接。由于容器内并没有真正的程序监听 8080，如果没有 DNAT，这个请求必然失败。
```bash
# 在宿主机执行：
nc -vz <容器IP> 8080
# 预期结果：succeeded!
```

**背后发生了什么？**
- 宿主机发往靶机 8080 端口的包，刚达到靶机网卡，随即进入 `prerouting` 钩子。
- 命中了 `dnat to <容器IP>:80` 规则。包的目的端口被瞬间篡改为 80。
- 包继续往前走进入 `input` 链（因为目的 IP 是自己），最终被真正在监听 80 端口的 `nc` 进程接手。
