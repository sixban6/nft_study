# 第五阶段：NAT 与路由指针 (网络黑魔法)

*类比 C 语言：指针操作与内存地址重写。*

---

在 C 语言中，你可以通过指针修改别人内存里的值。
在网络世界中，**NAT (Network Address Translation，网络地址转换)** 就是修改数据包的“寄件人地址 (源地址)”或“收件人地址 (目的地址)”。

这通常发生在路由器或者容器宿主机上（比如 Docker 就会大量使用 NAT）。在 `nftables` 中做 NAT，我们需要创建一个专门的 `nat` 表。

## 1. NAT 的时机：内核生命周期回顾

还记得那 5 个钩子吗？修改地址的时机是有严格讲究的。

- **Prerouting（路由前）**：你想要修改**包的目的地 (DNAT)** 时，必须在这里改。试想，如果路由已经做出了决定（向左走还是向右走），你再改目的地就晚了！
- **Postrouting（路由后）**：你想要修改**包的出发地 (SNAT)** 时，必须在这里改。此时路由已经定好，马上要出物理网卡了，临出门前赶紧把衣服上的名牌换成自己的。

## 2. Source NAT (SNAT) 与 Masquerade (源地址池隐藏)

**使用场景：把你的 Linux 变成一台路由器**。
假设你有一台服务器（两张网卡：`eth0` 连公网 IP，`eth1` 连内网 `192.168.1.0/24`）。内网的机器想上网，必须通过这台服务器。

内网机器发出的包，源地址是 `192.168.1.x`。如果服务器直接转发它去公网，公网的路由器是不认私网 IP 的，回包永远找不到路。
因此，服务器必须在包出城前，把源地址**替换**成服务器自己的公网 IP。

在 `nftables` 的 `nat` 表中：

```nftables
table ip nat {
    # 必须挂载在 postrouting（路由后）
    chain postrouting {
        type nat hook postrouting priority 100; policy accept;
        
        # 方式一：固定 IP 的 SNAT
        # 如果从内网发出的包属于 192.168.1.0/24，把它源地址改成 203.0.113.5
        ip saddr 192.168.1.0/24 snat to 203.0.113.5
        
        # 方式二：更智能的 Masquerade (伪装)
        # 如果你的公网 IP 不是固定的（比如 PPPoE 拨号或 DHCP 获取的）
        # Masquerade 会自动侦测出口网卡 eth0 当前的 IP，然后用它替换。
        oifname "eth0" masquerade
    }
}
```

## 3. Destination NAT (DNAT) 与端口映射

**使用场景：把公网流量转发给内网容器/服务器**。
假设你启动了一个 Docker 容器（内网 IP `172.17.0.2`，跑在 80 端口）。你想让外部访问你宿主机公网 IP 的 `8080` 端口时，自动连到容器去。

这属于典型的**端口映射**。因为包从外面进来，目的是你的宿主机 `8080`，你必须在**路由判断前**，把包的**目的地址和端口**强行改成容器的地址！

```nftables
table ip nat {
    # 必须挂载在 prerouting（路由前）
    chain prerouting {
        type nat hook prerouting priority -100; policy accept;
        
        # DNAT 规则：进站流量如果是请求 8080 端口的 TCP
        # 直接把目的地址改写成容器的 IP:80 端口！
        tcp dport 8080 dnat to 172.17.0.2:80
    }
}
```

> [!IMPORTANT]
> **NAT 的巨坑提醒：**
> 1. 要做 NAT 和路由转发，**必须**开启 Linux 内核的 IP 转发功能。否则无论你怎么配防火墙，包在路由环节就会被阻断。
>    `echo 1 > /proc/sys/net/ipv4/ip_forward` （临时生效）
>    修改 `/etc/sysctl.conf` 加一行 `net.ipv4.ip_forward = 1` （永久生效）。
> 2. NAT 仅仅是改地址，它仍然会受到 `filter` 表中 `forward` 链的过滤。所以除了写 NAT 规则，确保你的 `filter forward` 链也做了相应的 `accept` 放行！

### 验证端口映射 (DNAT)

我们来手工实现和验证类似 `docker run -p` 的流量转发魔法。

**测试目标：** 客户端请求网关靶机的 8080 端口，靶机通过 DNAT 将流量转交给内部真实的提供 80 端口的服务节点。由于配置中假设的容器后端 IP (`172.17.0.2`) 是写死的，请在应用规则前，把脚本里的 `172.17.0.2` 明确替换为你用来提供服务的容器 IP。

**1. 在后端容器启动监听：**
如果你在 `nft-lab` 上设置 NAT，我们可以找一台机器比如前面的**测试客户端容器**（假设 IP 为 `172.17.0.3`）作为后端服务。新开一个终端，在它里面前台启动 80 端口：
```bash
# 测试客户端终端执行
docker exec -it nft-client nc -l -p 80
```
把 NAT 脚本里 `dnat to` 的目标地址改成 `172.17.0.3:80`，并在靶机 `nft-lab` 应用它。

**2. 测试转发口：**
在另一台机器上（因为 Mac 的 Docker 限制，你可能需要再开第三个 Alpine 容器来充当外网用户），向 `nft-lab` (靶机网关，假设 IP `172.17.0.2`) 的代理端口 8080 发起连接：
```bash
# 在外网用户容器执行请求网关：
nc -vz 172.17.0.2 8080
# 预期结果：succeeded! 并且后端容器(172.17.0.3) 的 nc 会接收到这个连接。
```

**背后发生了什么？**
- 外部发往网关(靶机) 8080 端口的包，刚达到网关网卡，随即进入 `prerouting` 钩子。
- 命中了 `dnat to 172.17.0.3:80` 规则。包的目的地址和端口被瞬间篡改。
- 网关查路由表，发现目的是 172.17.0.3，于是交由 `forward` 链放行并转发。最终包顺利到达后端容器。
